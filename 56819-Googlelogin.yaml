# 変数に保存_authenticator
+store_value_2:
  action>: StoreValue
  key: token
  value: ${totp_token}
  private: false

# ブラウザを開く
+open_browser_1:
  action>: OpenBrowser
  url: 'https://accounts.google.com/ServiceLogin/identifier?service=wise&uilel=3&passive=true&continue=&followup=&ltmpl=forms&flowName=GlifWebSignIn&flowEntry=ServiceLogin'
  lang: 'ja-JP'
  userAgent: ${UA}
  headless: false
  windowSize: '1280 x 720'
  useShadowDomSelector: false
  plugins: ["stealth"]
  private: false

# 文字入力_メールアドレス
+type_text_1:
  action>: TypeText
  browser: +open_browser_1
  selector: '#identifierId'
  text: ${google_id}
  clearValue: false
  ignoreError: true
  private: false

# クリック_次へ
+click_1:
  action>: Click
  browser: +type_text_1
  selector: '//button/span[text()="次へ"]'
  confirm: true
  waitAfter: 5000
  ignoreError: true
  timeout: 30000
  private: false

# 要素を見つける_テキスト認証が表示されているか確認
+find_element_1:
  action>: FindElement
  browser: +click_1
  find_by: selector
  value: '#captchaimg'
  timeout: 5000
  visible: true
  private: false

# 変数に保存
+store_value_1:
  action>: StoreValue
  key: captchaimg
  value: +find_element_1
  private: false

# 真のとき_テキスト認証あるとき
+if_1:
  if>: ${!!captchaimg}
  _do:

    # CAPTCHAを解決
    +solve_captcha_1:
      action>: SolveCaptcha
      browser: +click_1
      type: normal
      selector: ${captchaimg}
      executeCallback: true
      private: false

    # 文字入力
    +type_text_3:
      action>: TypeText
      browser: +click_1
      selector: 'input[type="password"]'
      text: +solve_captcha_1
      clearValue: false
      ignoreError: true
      private: false

    # クリック
    +click_3:
      action>: Click
      browser: +type_text_3
      selector: '//button/span[text()="次へ"]'
      confirm: true
      waitAfter: 5000
      ignoreError: true
      timeout: 30000
      private: false

# 要素を見つける_パスワード要素あるか確認
+find_element_3:
  action>: FindElement
  browser: +click_1
  find_by: selector
  value: 'input[type="password"]'
  timeout: 10000
  visible: true
  private: false

# 変数に保存
+store_value_4:
  action>: StoreValue
  key: loginCheck
  value: +find_element_3
  private: false

# 真のとき_エラー出てるとき
+if_3:
  if>: ${!loginCheck}
  _do:

    # 強制終了
    +kill_attempt_1:
      action>: KillAttempt
      message: 'ログインに失敗しました。'
      private: false

# 文字入力_パスワード
+type_text_2:
  action>: TypeText
  browser: +click_1
  selector: 'input[type="password"]'
  text: ${password}
  clearValue: false
  ignoreError: true
  private: false

# クリック_次へ
+click_2:
  action>: Click
  browser: +type_text_2
  selector: '//button/span[text()="次へ"]'
  confirm: true
  waitAfter: 5000
  ignoreError: true
  timeout: 30000
  private: false

# 要素を見つける_totp出てるか確認
+find_element_2:
  action>: FindElement
  browser: +type_text_2
  find_by: selector
  value: 'input[name="totpPin"]'
  timeout: 10000
  visible: true
  private: false

# 変数に保存
+store_value_3:
  action>: StoreValue
  key: totpElm
  value: +find_element_2
  private: false

# 真のとき_totp表示されているとき
+if_2:
  if>: ${!!totpElm}
  _do:

    # ワンタイムパスワード発行
    +inject_script_1:
      action>: InjectScript
      browser: +click_2
      code: "var SUPPORTED_ALGS = 4 | 2 | 1;\n\n(function(global) {\n  \"use strict\";\n  /**\n   * Int_64 is a object for 2 32-bit numbers emulating a 64-bit number\n   *\n   * @private\n   * @constructor\n   * @this {Int_64}\n   * @param {number} msint_32 The most significant 32-bits of a 64-bit number\n   * @param {number} lsint_32 The least significant 32-bits of a 64-bit number\n   */\n  function Int_64(msint_32, lsint_32) {\n    this.highOrder = msint_32;\n    this.lowOrder = lsint_32;\n  }\n\n  /**\n   * Convert a string to an array of big-endian words\n   *\n   * There is a known bug with an odd number of existing bytes and using a\n   * UTF-16 encoding.  However, this function is used such that the existing\n   * bytes are always a result of a previous UTF-16 str2binb call and\n   * therefore there should never be an odd number of existing bytes\n   *\n   * @private\n   * @param {string} str String to be converted to binary representation\n   * @param {string} utfType The Unicode type, UTF8 or UTF16BE, UTF16LE, to\n   *   use to encode the source string\n   * @param {Array.<number>} existingBin A packed int array of bytes to\n   *   append the results to\n   * @param {number} existingBinLen The number of bits in the existingBin\n   *   array\n   * @return {{value : Array.<number>, binLen : number}} Hash list where\n   *   \"value\" contains the output number array and \"binLen\" is the binary\n   *   length of \"value\"\n   */\n  function str2binb(str, utfType, existingBin, existingBinLen) {\n    var bin = [],\n      codePnt,\n      binArr = [],\n      byteCnt = 0,\n      i,\n      j,\n      existingByteLen,\n      intOffset,\n      byteOffset;\n\n    bin = existingBin || [0];\n    existingBinLen = existingBinLen || 0;\n    existingByteLen = existingBinLen >>> 3;\n\n    if (\"UTF8\" === utfType) {\n      for (i = 0; i < str.length; i += 1) {\n        codePnt = str.charCodeAt(i);\n        binArr = [];\n\n        if (0x80 > codePnt) {\n          binArr.push(codePnt);\n        } else if (0x800 > codePnt) {\n          binArr.push(0xc0 | (codePnt >>> 6));\n          binArr.push(0x80 | (codePnt & 0x3f));\n        } else if (0xd800 > codePnt || 0xe000 <= codePnt) {\n          binArr.push(\n            0xe0 | (codePnt >>> 12),\n            0x80 | ((codePnt >>> 6) & 0x3f),\n            0x80 | (codePnt & 0x3f)\n          );\n        } else {\n          i += 1;\n          codePnt =\n            0x10000 + (((codePnt & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\n          binArr.push(\n            0xf0 | (codePnt >>> 18),\n            0x80 | ((codePnt >>> 12) & 0x3f),\n            0x80 | ((codePnt >>> 6) & 0x3f),\n            0x80 | (codePnt & 0x3f)\n          );\n        }\n\n        for (j = 0; j < binArr.length; j += 1) {\n          byteOffset = byteCnt + existingByteLen;\n          intOffset = byteOffset >>> 2;\n          while (bin.length <= intOffset) {\n            bin.push(0);\n          }\n          /* Known bug kicks in here */\n          bin[intOffset] |= binArr[j] << (8 * (3 - (byteOffset % 4)));\n          byteCnt += 1;\n        }\n      }\n    } else if (\"UTF16BE\" === utfType || \"UTF16LE\" === utfType) {\n      for (i = 0; i < str.length; i += 1) {\n        codePnt = str.charCodeAt(i);\n        /* Internally strings are UTF-16BE so only change if UTF-16LE */\n        if (\"UTF16LE\" === utfType) {\n          j = codePnt & 0xff;\n          codePnt = (j << 8) | (codePnt >>> 8);\n        }\n\n        byteOffset = byteCnt + existingByteLen;\n        intOffset = byteOffset >>> 2;\n        while (bin.length <= intOffset) {\n          bin.push(0);\n        }\n        bin[intOffset] |= codePnt << (8 * (2 - (byteOffset % 4)));\n        byteCnt += 2;\n      }\n    }\n    return { value: bin, binLen: byteCnt * 8 + existingBinLen };\n  }\n\n  /**\n   * Convert a hex string to an array of big-endian words\n   *\n   * @private\n   * @param {string} str String to be converted to binary representation\n   * @param {Array.<number>} existingBin A packed int array of bytes to\n   *   append the results to\n   * @param {number} existingBinLen The number of bits in the existingBin\n   *   array\n   * @return {{value : Array.<number>, binLen : number}} Hash list where\n   *   \"value\" contains the output number array and \"binLen\" is the binary\n   *   length of \"value\"\n   */\n  function hex2binb(str, existingBin, existingBinLen) {\n    var bin,\n      length = str.length,\n      i,\n      num,\n      intOffset,\n      byteOffset,\n      existingByteLen;\n\n    bin = existingBin || [0];\n    existingBinLen = existingBinLen || 0;\n    existingByteLen = existingBinLen >>> 3;\n\n    for (i = 0; i < length; i += 2) {\n      num = parseInt(str.substr(i, 2), 16);\n      if (!isNaN(num)) {\n        byteOffset = (i >>> 1) + existingByteLen;\n        intOffset = byteOffset >>> 2;\n        while (bin.length <= intOffset) {\n          bin.push(0);\n        }\n        bin[intOffset] |= num << (8 * (3 - (byteOffset % 4)));\n      } else {\n        throw new Error(\"String of HEX type contains invalid characters\");\n      }\n    }\n\n    return { value: bin, binLen: length * 4 + existingBinLen };\n  }\n\n  /**\n   * Convert a string of raw bytes to an array of big-endian words\n   *\n   * @private\n   * @param {string} str String of raw bytes to be converted to binary representation\n   * @param {Array.<number>} existingBin A packed int array of bytes to\n   *   append the results to\n   * @param {number} existingBinLen The number of bits in the existingBin\n   *   array\n   * @return {{value : Array.<number>, binLen : number}} Hash list where\n   *   \"value\" contains the output number array and \"binLen\" is the binary\n   *   length of \"value\"\n   */\n  function bytes2binb(str, existingBin, existingBinLen) {\n    var bin = [],\n      codePnt,\n      i,\n      existingByteLen,\n      intOffset,\n      byteOffset;\n\n    bin = existingBin || [0];\n    existingBinLen = existingBinLen || 0;\n    existingByteLen = existingBinLen >>> 3;\n\n    for (i = 0; i < str.length; i += 1) {\n      codePnt = str.charCodeAt(i);\n\n      byteOffset = i + existingByteLen;\n      intOffset = byteOffset >>> 2;\n      if (bin.length <= intOffset) {\n        bin.push(0);\n      }\n      bin[intOffset] |= codePnt << (8 * (3 - (byteOffset % 4)));\n    }\n\n    return { value: bin, binLen: str.length * 8 + existingBinLen };\n  }\n\n  /**\n   * Convert a base-64 string to an array of big-endian words\n   *\n   * @private\n   * @param {string} str String to be converted to binary representation\n   * @param {Array.<number>} existingBin A packed int array of bytes to\n   *   append the results to\n   * @param {number} existingBinLen The number of bits in the existingBin\n   *   array\n   * @return {{value : Array.<number>, binLen : number}} Hash list where\n   *   \"value\" contains the output number array and \"binLen\" is the binary\n   *   length of \"value\"\n   */\n  function b642binb(str, existingBin, existingBinLen) {\n    var bin = [],\n      byteCnt = 0,\n      index,\n      i,\n      j,\n      tmpInt,\n      strPart,\n      firstEqual,\n      b64Tab =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n      existingByteLen,\n      intOffset,\n      byteOffset;\n\n    bin = existingBin || [0];\n    existingBinLen = existingBinLen || 0;\n    existingByteLen = existingBinLen >>> 3;\n\n    if (-1 === str.search(/^[a-zA-Z0-9=+\\/]+$/)) {\n      throw new Error(\"Invalid character in base-64 string\");\n    }\n    firstEqual = str.indexOf(\"=\");\n    str = str.replace(/\\=/g, \"\");\n    if (-1 !== firstEqual && firstEqual < str.length) {\n      throw new Error(\"Invalid '=' found in base-64 string\");\n    }\n\n    for (i = 0; i < str.length; i += 4) {\n      strPart = str.substr(i, 4);\n      tmpInt = 0;\n\n      for (j = 0; j < strPart.length; j += 1) {\n        index = b64Tab.indexOf(strPart[j]);\n        tmpInt |= index << (18 - 6 * j);\n      }\n\n      for (j = 0; j < strPart.length - 1; j += 1) {\n        byteOffset = byteCnt + existingByteLen;\n        intOffset = byteOffset >>> 2;\n        while (bin.length <= intOffset) {\n          bin.push(0);\n        }\n        bin[intOffset] |=\n          ((tmpInt >>> (16 - j * 8)) & 0xff) << (8 * (3 - (byteOffset % 4)));\n        byteCnt += 1;\n      }\n    }\n\n    return { value: bin, binLen: byteCnt * 8 + existingBinLen };\n  }\n\n  /**\n   * Convert an array of big-endian words to a hex string.\n   *\n   * @private\n   * @param {Array.<number>} binarray Array of integers to be converted to\n   *   hexidecimal representation\n   * @param {{outputUpper : boolean, b64Pad : string}} formatOpts Hash list\n   *   containing validated output formatting options\n   * @return {string} Hexidecimal representation of the parameter in string\n   *   form\n   */\n  function binb2hex(binarray, formatOpts) {\n    var hex_tab = \"0123456789abcdef\",\n      str = \"\",\n      length = binarray.length * 4,\n      i,\n      srcByte;\n\n    for (i = 0; i < length; i += 1) {\n      /* The below is more than a byte but it gets taken care of later */\n      srcByte = binarray[i >>> 2] >>> ((3 - (i % 4)) * 8);\n      str +=\n        hex_tab.charAt((srcByte >>> 4) & 0xf) + hex_tab.charAt(srcByte & 0xf);\n    }\n\n    return formatOpts[\"outputUpper\"] ? str.toUpperCase() : str;\n  }\n\n  /**\n   * Convert an array of big-endian words to a base-64 string\n   *\n   * @private\n   * @param {Array.<number>} binarray Array of integers to be converted to\n   *   base-64 representation\n   * @param {{outputUpper : boolean, b64Pad : string}} formatOpts Hash list\n   *   containing validated output formatting options\n   * @return {string} Base-64 encoded representation of the parameter in\n   *   string form\n   */\n  function binb2b64(binarray, formatOpts) {\n    var str = \"\",\n      length = binarray.length * 4,\n      i,\n      j,\n      triplet,\n      offset,\n      int1,\n      int2,\n      b64Tab =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    for (i = 0; i < length; i += 3) {\n      offset = (i + 1) >>> 2;\n      int1 = binarray.length <= offset ? 0 : binarray[offset];\n      offset = (i + 2) >>> 2;\n      int2 = binarray.length <= offset ? 0 : binarray[offset];\n      triplet =\n        (((binarray[i >>> 2] >>> (8 * (3 - (i % 4)))) & 0xff) << 16) |\n        (((int1 >>> (8 * (3 - ((i + 1) % 4)))) & 0xff) << 8) |\n        ((int2 >>> (8 * (3 - ((i + 2) % 4)))) & 0xff);\n      for (j = 0; j < 4; j += 1) {\n        if (i * 8 + j * 6 <= binarray.length * 32) {\n          str += b64Tab.charAt((triplet >>> (6 * (3 - j))) & 0x3f);\n        } else {\n          str += formatOpts[\"b64Pad\"];\n        }\n      }\n    }\n    return str;\n  }\n\n  /**\n   * Convert an array of big-endian words to raw bytes string\n   *\n   * @private\n   * @param {Array.<number>} binarray Array of integers to be converted to\n   *   a raw bytes string representation\n   * @return {string} Raw bytes representation of the parameter in string\n   *   form\n   */\n  function binb2bytes(binarray) {\n    var str = \"\",\n      length = binarray.length * 4,\n      i,\n      srcByte;\n\n    for (i = 0; i < length; i += 1) {\n      srcByte = (binarray[i >>> 2] >>> ((3 - (i % 4)) * 8)) & 0xff;\n      str += String.fromCharCode(srcByte);\n    }\n\n    return str;\n  }\n\n  /**\n   * Validate hash list containing output formatting options, ensuring\n   * presence of every option or adding the default value\n   *\n   * @private\n   * @param {{outputUpper : (boolean|undefined), b64Pad : (string|undefined)}=}\n   *   options Hash list of output formatting options\n   * @return {{outputUpper : boolean, b64Pad : string}} Validated hash list\n   *   containing output formatting options\n   */\n  function getOutputOpts(options) {\n    var retVal = { outputUpper: false, b64Pad: \"=\" },\n      outputOptions;\n    outputOptions = options || {};\n\n    retVal[\"outputUpper\"] = outputOptions[\"outputUpper\"] || false;\n    retVal[\"b64Pad\"] = outputOptions[\"b64Pad\"] || \"=\";\n\n    if (\"boolean\" !== typeof retVal[\"outputUpper\"]) {\n      throw new Error(\"Invalid outputUpper formatting option\");\n    }\n\n    if (\"string\" !== typeof retVal[\"b64Pad\"]) {\n      throw new Error(\"Invalid b64Pad formatting option\");\n    }\n\n    return retVal;\n  }\n\n  /**\n   * Function that takes an input format and UTF encoding and returns the\n   * appropriate function used to convert the input.\n   *\n   * @private\n   * @param {string} format The format of the string to be converted\n   * @param {string} utfType The string encoding to use (UTF8, UTF16BE,\n   *	UTF16LE)\n   * @return {function(string, Array.<number>=, number=): {value :\n   *   Array.<number>, binLen : number}} Function that will convert an input\n   *   string to a packed int array\n   */\n  function getStrConverter(format, utfType) {\n    var retVal;\n\n    /* Validate encoding */\n    switch (utfType) {\n      case \"UTF8\":\n      /* Fallthrough */\n      case \"UTF16BE\":\n      /* Fallthrough */\n      case \"UTF16LE\":\n        /* Fallthrough */\n        break;\n      default:\n        throw new Error(\"encoding must be UTF8, UTF16BE, or UTF16LE\");\n    }\n\n    /* Map inputFormat to the appropriate converter */\n    switch (format) {\n      case \"HEX\":\n        retVal = hex2binb;\n        break;\n      case \"TEXT\":\n        retVal = function(str, existingBin, existingBinLen) {\n          return str2binb(str, utfType, existingBin, existingBinLen);\n        };\n        break;\n      case \"B64\":\n        retVal = b642binb;\n        break;\n      case \"BYTES\":\n        retVal = bytes2binb;\n        break;\n      default:\n        throw new Error(\"format must be HEX, TEXT, B64, or BYTES\");\n    }\n\n    return retVal;\n  }\n\n  /**\n   * The 32-bit implementation of circular rotate left\n   *\n   * @private\n   * @param {number} x The 32-bit integer argument\n   * @param {number} n The number of bits to shift\n   * @return {number} The x shifted circularly by n bits\n   */\n  function rotl_32(x, n) {\n    return (x << n) | (x >>> (32 - n));\n  }\n\n  /**\n   * The 32-bit implementation of circular rotate right\n   *\n   * @private\n   * @param {number} x The 32-bit integer argument\n   * @param {number} n The number of bits to shift\n   * @return {number} The x shifted circularly by n bits\n   */\n  function rotr_32(x, n) {\n    return (x >>> n) | (x << (32 - n));\n  }\n\n  /**\n   * The 64-bit implementation of circular rotate right\n   *\n   * @private\n   * @param {Int_64} x The 64-bit integer argument\n   * @param {number} n The number of bits to shift\n   * @return {Int_64} The x shifted circularly by n bits\n   */\n  function rotr_64(x, n) {\n    var retVal = null,\n      tmp = new Int_64(x.highOrder, x.lowOrder);\n\n    if (32 >= n) {\n      retVal = new Int_64(\n        (tmp.highOrder >>> n) | ((tmp.lowOrder << (32 - n)) & 0xffffffff),\n        (tmp.lowOrder >>> n) | ((tmp.highOrder << (32 - n)) & 0xffffffff)\n      );\n    } else {\n      retVal = new Int_64(\n        (tmp.lowOrder >>> (n - 32)) |\n          ((tmp.highOrder << (64 - n)) & 0xffffffff),\n        (tmp.highOrder >>> (n - 32)) | ((tmp.lowOrder << (64 - n)) & 0xffffffff)\n      );\n    }\n\n    return retVal;\n  }\n\n  /**\n   * The 32-bit implementation of shift right\n   *\n   * @private\n   * @param {number} x The 32-bit integer argument\n   * @param {number} n The number of bits to shift\n   * @return {number} The x shifted by n bits\n   */\n  function shr_32(x, n) {\n    return x >>> n;\n  }\n\n  /**\n   * The 64-bit implementation of shift right\n   *\n   * @private\n   * @param {Int_64} x The 64-bit integer argument\n   * @param {number} n The number of bits to shift\n   * @return {Int_64} The x shifted by n bits\n   */\n  function shr_64(x, n) {\n    var retVal = null;\n\n    if (32 >= n) {\n      retVal = new Int_64(\n        x.highOrder >>> n,\n        (x.lowOrder >>> n) | ((x.highOrder << (32 - n)) & 0xffffffff)\n      );\n    } else {\n      retVal = new Int_64(0, x.highOrder >>> (n - 32));\n    }\n\n    return retVal;\n  }\n\n  /**\n   * The 32-bit implementation of the NIST specified Parity function\n   *\n   * @private\n   * @param {number} x The first 32-bit integer argument\n   * @param {number} y The second 32-bit integer argument\n   * @param {number} z The third 32-bit integer argument\n   * @return {number} The NIST specified output of the function\n   */\n  function parity_32(x, y, z) {\n    return x ^ y ^ z;\n  }\n\n  /**\n   * The 32-bit implementation of the NIST specified Ch function\n   *\n   * @private\n   * @param {number} x The first 32-bit integer argument\n   * @param {number} y The second 32-bit integer argument\n   * @param {number} z The third 32-bit integer argument\n   * @return {number} The NIST specified output of the function\n   */\n  function ch_32(x, y, z) {\n    return (x & y) ^ (~x & z);\n  }\n\n  /**\n   * The 64-bit implementation of the NIST specified Ch function\n   *\n   * @private\n   * @param {Int_64} x The first 64-bit integer argument\n   * @param {Int_64} y The second 64-bit integer argument\n   * @param {Int_64} z The third 64-bit integer argument\n   * @return {Int_64} The NIST specified output of the function\n   */\n  function ch_64(x, y, z) {\n    return new Int_64(\n      (x.highOrder & y.highOrder) ^ (~x.highOrder & z.highOrder),\n      (x.lowOrder & y.lowOrder) ^ (~x.lowOrder & z.lowOrder)\n    );\n  }\n\n  /**\n   * The 32-bit implementation of the NIST specified Maj function\n   *\n   * @private\n   * @param {number} x The first 32-bit integer argument\n   * @param {number} y The second 32-bit integer argument\n   * @param {number} z The third 32-bit integer argument\n   * @return {number} The NIST specified output of the function\n   */\n  function maj_32(x, y, z) {\n    return (x & y) ^ (x & z) ^ (y & z);\n  }\n\n  /**\n   * The 64-bit implementation of the NIST specified Maj function\n   *\n   * @private\n   * @param {Int_64} x The first 64-bit integer argument\n   * @param {Int_64} y The second 64-bit integer argument\n   * @param {Int_64} z The third 64-bit integer argument\n   * @return {Int_64} The NIST specified output of the function\n   */\n  function maj_64(x, y, z) {\n    return new Int_64(\n      (x.highOrder & y.highOrder) ^\n        (x.highOrder & z.highOrder) ^\n        (y.highOrder & z.highOrder),\n      (x.lowOrder & y.lowOrder) ^\n        (x.lowOrder & z.lowOrder) ^\n        (y.lowOrder & z.lowOrder)\n    );\n  }\n\n  /**\n   * The 32-bit implementation of the NIST specified Sigma0 function\n   *\n   * @private\n   * @param {number} x The 32-bit integer argument\n   * @return {number} The NIST specified output of the function\n   */\n  function sigma0_32(x) {\n    return rotr_32(x, 2) ^ rotr_32(x, 13) ^ rotr_32(x, 22);\n  }\n\n  /**\n   * The 64-bit implementation of the NIST specified Sigma0 function\n   *\n   * @private\n   * @param {Int_64} x The 64-bit integer argument\n   * @return {Int_64} The NIST specified output of the function\n   */\n  function sigma0_64(x) {\n    var rotr28 = rotr_64(x, 28),\n      rotr34 = rotr_64(x, 34),\n      rotr39 = rotr_64(x, 39);\n\n    return new Int_64(\n      rotr28.highOrder ^ rotr34.highOrder ^ rotr39.highOrder,\n      rotr28.lowOrder ^ rotr34.lowOrder ^ rotr39.lowOrder\n    );\n  }\n\n  /**\n   * The 32-bit implementation of the NIST specified Sigma1 function\n   *\n   * @private\n   * @param {number} x The 32-bit integer argument\n   * @return {number} The NIST specified output of the function\n   */\n  function sigma1_32(x) {\n    return rotr_32(x, 6) ^ rotr_32(x, 11) ^ rotr_32(x, 25);\n  }\n\n  /**\n   * The 64-bit implementation of the NIST specified Sigma1 function\n   *\n   * @private\n   * @param {Int_64} x The 64-bit integer argument\n   * @return {Int_64} The NIST specified output of the function\n   */\n  function sigma1_64(x) {\n    var rotr14 = rotr_64(x, 14),\n      rotr18 = rotr_64(x, 18),\n      rotr41 = rotr_64(x, 41);\n\n    return new Int_64(\n      rotr14.highOrder ^ rotr18.highOrder ^ rotr41.highOrder,\n      rotr14.lowOrder ^ rotr18.lowOrder ^ rotr41.lowOrder\n    );\n  }\n\n  /**\n   * The 32-bit implementation of the NIST specified Gamma0 function\n   *\n   * @private\n   * @param {number} x The 32-bit integer argument\n   * @return {number} The NIST specified output of the function\n   */\n  function gamma0_32(x) {\n    return rotr_32(x, 7) ^ rotr_32(x, 18) ^ shr_32(x, 3);\n  }\n\n  /**\n   * The 64-bit implementation of the NIST specified Gamma0 function\n   *\n   * @private\n   * @param {Int_64} x The 64-bit integer argument\n   * @return {Int_64} The NIST specified output of the function\n   */\n  function gamma0_64(x) {\n    var rotr1 = rotr_64(x, 1),\n      rotr8 = rotr_64(x, 8),\n      shr7 = shr_64(x, 7);\n\n    return new Int_64(\n      rotr1.highOrder ^ rotr8.highOrder ^ shr7.highOrder,\n      rotr1.lowOrder ^ rotr8.lowOrder ^ shr7.lowOrder\n    );\n  }\n\n  /**\n   * The 32-bit implementation of the NIST specified Gamma1 function\n   *\n   * @private\n   * @param {number} x The 32-bit integer argument\n   * @return {number} The NIST specified output of the function\n   */\n  function gamma1_32(x) {\n    return rotr_32(x, 17) ^ rotr_32(x, 19) ^ shr_32(x, 10);\n  }\n\n  /**\n   * The 64-bit implementation of the NIST specified Gamma1 function\n   *\n   * @private\n   * @param {Int_64} x The 64-bit integer argument\n   * @return {Int_64} The NIST specified output of the function\n   */\n  function gamma1_64(x) {\n    var rotr19 = rotr_64(x, 19),\n      rotr61 = rotr_64(x, 61),\n      shr6 = shr_64(x, 6);\n\n    return new Int_64(\n      rotr19.highOrder ^ rotr61.highOrder ^ shr6.highOrder,\n      rotr19.lowOrder ^ rotr61.lowOrder ^ shr6.lowOrder\n    );\n  }\n\n  /**\n   * Add two 32-bit integers, wrapping at 2^32. This uses 16-bit operations\n   * internally to work around bugs in some JS interpreters.\n   *\n   * @private\n   * @param {number} a The first 32-bit integer argument to be added\n   * @param {number} b The second 32-bit integer argument to be added\n   * @return {number} The sum of a + b\n   */\n  function safeAdd_32_2(a, b) {\n    var lsw = (a & 0xffff) + (b & 0xffff),\n      msw = (a >>> 16) + (b >>> 16) + (lsw >>> 16);\n\n    return ((msw & 0xffff) << 16) | (lsw & 0xffff);\n  }\n\n  /**\n   * Add four 32-bit integers, wrapping at 2^32. This uses 16-bit operations\n   * internally to work around bugs in some JS interpreters.\n   *\n   * @private\n   * @param {number} a The first 32-bit integer argument to be added\n   * @param {number} b The second 32-bit integer argument to be added\n   * @param {number} c The third 32-bit integer argument to be added\n   * @param {number} d The fourth 32-bit integer argument to be added\n   * @return {number} The sum of a + b + c + d\n   */\n  function safeAdd_32_4(a, b, c, d) {\n    var lsw = (a & 0xffff) + (b & 0xffff) + (c & 0xffff) + (d & 0xffff),\n      msw = (a >>> 16) + (b >>> 16) + (c >>> 16) + (d >>> 16) + (lsw >>> 16);\n\n    return ((msw & 0xffff) << 16) | (lsw & 0xffff);\n  }\n\n  /**\n   * Add five 32-bit integers, wrapping at 2^32. This uses 16-bit operations\n   * internally to work around bugs in some JS interpreters.\n   *\n   * @private\n   * @param {number} a The first 32-bit integer argument to be added\n   * @param {number} b The second 32-bit integer argument to be added\n   * @param {number} c The third 32-bit integer argument to be added\n   * @param {number} d The fourth 32-bit integer argument to be added\n   * @param {number} e The fifth 32-bit integer argument to be added\n   * @return {number} The sum of a + b + c + d + e\n   */\n  function safeAdd_32_5(a, b, c, d, e) {\n    var lsw =\n        (a & 0xffff) +\n        (b & 0xffff) +\n        (c & 0xffff) +\n        (d & 0xffff) +\n        (e & 0xffff),\n      msw =\n        (a >>> 16) +\n        (b >>> 16) +\n        (c >>> 16) +\n        (d >>> 16) +\n        (e >>> 16) +\n        (lsw >>> 16);\n\n    return ((msw & 0xffff) << 16) | (lsw & 0xffff);\n  }\n\n  /**\n   * Add two 64-bit integers, wrapping at 2^64. This uses 16-bit operations\n   * internally to work around bugs in some JS interpreters.\n   *\n   * @private\n   * @param {Int_64} x The first 64-bit integer argument to be added\n   * @param {Int_64} y The second 64-bit integer argument to be added\n   * @return {Int_64} The sum of x + y\n   */\n  function safeAdd_64_2(x, y) {\n    var lsw, msw, lowOrder, highOrder;\n\n    lsw = (x.lowOrder & 0xffff) + (y.lowOrder & 0xffff);\n    msw = (x.lowOrder >>> 16) + (y.lowOrder >>> 16) + (lsw >>> 16);\n    lowOrder = ((msw & 0xffff) << 16) | (lsw & 0xffff);\n\n    lsw = (x.highOrder & 0xffff) + (y.highOrder & 0xffff) + (msw >>> 16);\n    msw = (x.highOrder >>> 16) + (y.highOrder >>> 16) + (lsw >>> 16);\n    highOrder = ((msw & 0xffff) << 16) | (lsw & 0xffff);\n\n    return new Int_64(highOrder, lowOrder);\n  }\n\n  /**\n   * Add four 64-bit integers, wrapping at 2^64. This uses 16-bit operations\n   * internally to work around bugs in some JS interpreters.\n   *\n   * @private\n   * @param {Int_64} a The first 64-bit integer argument to be added\n   * @param {Int_64} b The second 64-bit integer argument to be added\n   * @param {Int_64} c The third 64-bit integer argument to be added\n   * @param {Int_64} d The fouth 64-bit integer argument to be added\n   * @return {Int_64} The sum of a + b + c + d\n   */\n  function safeAdd_64_4(a, b, c, d) {\n    var lsw, msw, lowOrder, highOrder;\n\n    lsw =\n      (a.lowOrder & 0xffff) +\n      (b.lowOrder & 0xffff) +\n      (c.lowOrder & 0xffff) +\n      (d.lowOrder & 0xffff);\n    msw =\n      (a.lowOrder >>> 16) +\n      (b.lowOrder >>> 16) +\n      (c.lowOrder >>> 16) +\n      (d.lowOrder >>> 16) +\n      (lsw >>> 16);\n    lowOrder = ((msw & 0xffff) << 16) | (lsw & 0xffff);\n\n    lsw =\n      (a.highOrder & 0xffff) +\n      (b.highOrder & 0xffff) +\n      (c.highOrder & 0xffff) +\n      (d.highOrder & 0xffff) +\n      (msw >>> 16);\n    msw =\n      (a.highOrder >>> 16) +\n      (b.highOrder >>> 16) +\n      (c.highOrder >>> 16) +\n      (d.highOrder >>> 16) +\n      (lsw >>> 16);\n    highOrder = ((msw & 0xffff) << 16) | (lsw & 0xffff);\n\n    return new Int_64(highOrder, lowOrder);\n  }\n\n  /**\n   * Add five 64-bit integers, wrapping at 2^64. This uses 16-bit operations\n   * internally to work around bugs in some JS interpreters.\n   *\n   * @private\n   * @param {Int_64} a The first 64-bit integer argument to be added\n   * @param {Int_64} b The second 64-bit integer argument to be added\n   * @param {Int_64} c The third 64-bit integer argument to be added\n   * @param {Int_64} d The fouth 64-bit integer argument to be added\n   * @param {Int_64} e The fouth 64-bit integer argument to be added\n   * @return {Int_64} The sum of a + b + c + d + e\n   */\n  function safeAdd_64_5(a, b, c, d, e) {\n    var lsw, msw, lowOrder, highOrder;\n\n    lsw =\n      (a.lowOrder & 0xffff) +\n      (b.lowOrder & 0xffff) +\n      (c.lowOrder & 0xffff) +\n      (d.lowOrder & 0xffff) +\n      (e.lowOrder & 0xffff);\n    msw =\n      (a.lowOrder >>> 16) +\n      (b.lowOrder >>> 16) +\n      (c.lowOrder >>> 16) +\n      (d.lowOrder >>> 16) +\n      (e.lowOrder >>> 16) +\n      (lsw >>> 16);\n    lowOrder = ((msw & 0xffff) << 16) | (lsw & 0xffff);\n\n    lsw =\n      (a.highOrder & 0xffff) +\n      (b.highOrder & 0xffff) +\n      (c.highOrder & 0xffff) +\n      (d.highOrder & 0xffff) +\n      (e.highOrder & 0xffff) +\n      (msw >>> 16);\n    msw =\n      (a.highOrder >>> 16) +\n      (b.highOrder >>> 16) +\n      (c.highOrder >>> 16) +\n      (d.highOrder >>> 16) +\n      (e.highOrder >>> 16) +\n      (lsw >>> 16);\n    highOrder = ((msw & 0xffff) << 16) | (lsw & 0xffff);\n\n    return new Int_64(highOrder, lowOrder);\n  }\n\n  /**\n   * Gets the H values for the specified SHA variant\n   *\n   * @param {string} variant The SHA variant\n   * @return {Array.<number|Int_64>} The initial H values\n   */\n  function getH(variant) {\n    var retVal, H_trunc, H_full;\n\n    if (\"SHA-1\" === variant && 1 & SUPPORTED_ALGS) {\n      retVal = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n    } else if (6 & SUPPORTED_ALGS) {\n      H_trunc = [\n        0xc1059ed8,\n        0x367cd507,\n        0x3070dd17,\n        0xf70e5939,\n        0xffc00b31,\n        0x68581511,\n        0x64f98fa7,\n        0xbefa4fa4\n      ];\n      H_full = [\n        0x6a09e667,\n        0xbb67ae85,\n        0x3c6ef372,\n        0xa54ff53a,\n        0x510e527f,\n        0x9b05688c,\n        0x1f83d9ab,\n        0x5be0cd19\n      ];\n\n      switch (variant) {\n        case \"SHA-224\":\n          retVal = H_trunc;\n          break;\n        case \"SHA-256\":\n          retVal = H_full;\n          break;\n        case \"SHA-384\":\n          retVal = [\n            new Int_64(0xcbbb9d5d, H_trunc[0]),\n            new Int_64(0x0629a292a, H_trunc[1]),\n            new Int_64(0x9159015a, H_trunc[2]),\n            new Int_64(0x0152fecd8, H_trunc[3]),\n            new Int_64(0x67332667, H_trunc[4]),\n            new Int_64(0x98eb44a87, H_trunc[5]),\n            new Int_64(0xdb0c2e0d, H_trunc[6]),\n            new Int_64(0x047b5481d, H_trunc[7])\n          ];\n          break;\n        case \"SHA-512\":\n          retVal = [\n            new Int_64(H_full[0], 0xf3bcc908),\n            new Int_64(H_full[1], 0x84caa73b),\n            new Int_64(H_full[2], 0xfe94f82b),\n            new Int_64(H_full[3], 0x5f1d36f1),\n            new Int_64(H_full[4], 0xade682d1),\n            new Int_64(H_full[5], 0x2b3e6c1f),\n            new Int_64(H_full[6], 0xfb41bd6b),\n            new Int_64(H_full[7], 0x137e2179)\n          ];\n          break;\n        default:\n          throw new Error(\"Unknown SHA variant\");\n      }\n    } else {\n      throw new Error(\"No SHA variants supported\");\n    }\n\n    return retVal;\n  }\n\n  /**\n   * Performs a round of SHA-1 hashing over a 512-byte block\n   *\n   * @private\n   * @param {Array.<number>} block The binary array representation of the\n   *   block to hash\n   * @param {Array.<number>} H The intermediate H values from a previous\n   *   round\n   * @return {Array.<number>} The resulting H values\n   */\n  function roundSHA1(block, H) {\n    var W = [],\n      a,\n      b,\n      c,\n      d,\n      e,\n      T,\n      ch = ch_32,\n      parity = parity_32,\n      maj = maj_32,\n      rotl = rotl_32,\n      safeAdd_2 = safeAdd_32_2,\n      t,\n      safeAdd_5 = safeAdd_32_5;\n\n    a = H[0];\n    b = H[1];\n    c = H[2];\n    d = H[3];\n    e = H[4];\n\n    for (t = 0; t < 80; t += 1) {\n      if (t < 16) {\n        W[t] = block[t];\n      } else {\n        W[t] = rotl(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n      }\n\n      if (t < 20) {\n        T = safeAdd_5(rotl(a, 5), ch(b, c, d), e, 0x5a827999, W[t]);\n      } else if (t < 40) {\n        T = safeAdd_5(rotl(a, 5), parity(b, c, d), e, 0x6ed9eba1, W[t]);\n      } else if (t < 60) {\n        T = safeAdd_5(rotl(a, 5), maj(b, c, d), e, 0x8f1bbcdc, W[t]);\n      } else {\n        T = safeAdd_5(rotl(a, 5), parity(b, c, d), e, 0xca62c1d6, W[t]);\n      }\n\n      e = d;\n      d = c;\n      c = rotl(b, 30);\n      b = a;\n      a = T;\n    }\n\n    H[0] = safeAdd_2(a, H[0]);\n    H[1] = safeAdd_2(b, H[1]);\n    H[2] = safeAdd_2(c, H[2]);\n    H[3] = safeAdd_2(d, H[3]);\n    H[4] = safeAdd_2(e, H[4]);\n\n    return H;\n  }\n\n  /**\n   * Finalizes the SHA-1 hash\n   *\n   * @private\n   * @param {Array.<number>} remainder Any leftover unprocessed packed ints\n   *   that still need to be processed\n   * @param {number} remainderBinLen The number of bits in remainder\n   * @param {number} processedBinLen The number of bits already\n   *   processed\n   * @param {Array.<number>} H The intermediate H values from a previous\n   *   round\n   * @return {Array.<number>} The array of integers representing the SHA-1\n   *   hash of message\n   */\n  function finalizeSHA1(remainder, remainderBinLen, processedBinLen, H) {\n    var i, appendedMessageLength, offset;\n\n    /* The 65 addition is a hack but it works.  The correct number is\n		   actually 72 (64 + 8) but the below math fails if\n		   remainderBinLen + 72 % 512 = 0. Since remainderBinLen % 8 = 0,\n		   \"shorting\" the addition is OK. */\n    offset = (((remainderBinLen + 65) >>> 9) << 4) + 15;\n    while (remainder.length <= offset) {\n      remainder.push(0);\n    }\n    /* Append '1' at the end of the binary string */\n    remainder[remainderBinLen >>> 5] |= 0x80 << (24 - (remainderBinLen % 32));\n    /* Append length of binary string in the position such that the new\n		length is a multiple of 512.  Logic does not work for even multiples\n		of 512 but there can never be even multiples of 512 */\n    remainder[offset] = remainderBinLen + processedBinLen;\n\n    appendedMessageLength = remainder.length;\n\n    /* This will always be at least 1 full chunk */\n    for (i = 0; i < appendedMessageLength; i += 16) {\n      H = roundSHA1(remainder.slice(i, i + 16), H);\n    }\n\n    return H;\n  }\n\n  /* Put this here so the K arrays aren't put on the stack for every block */\n  var K_sha2, K_sha512;\n  if (6 & SUPPORTED_ALGS) {\n    K_sha2 = [\n      0x428a2f98,\n      0x71374491,\n      0xb5c0fbcf,\n      0xe9b5dba5,\n      0x3956c25b,\n      0x59f111f1,\n      0x923f82a4,\n      0xab1c5ed5,\n      0xd807aa98,\n      0x12835b01,\n      0x243185be,\n      0x550c7dc3,\n      0x72be5d74,\n      0x80deb1fe,\n      0x9bdc06a7,\n      0xc19bf174,\n      0xe49b69c1,\n      0xefbe4786,\n      0x0fc19dc6,\n      0x240ca1cc,\n      0x2de92c6f,\n      0x4a7484aa,\n      0x5cb0a9dc,\n      0x76f988da,\n      0x983e5152,\n      0xa831c66d,\n      0xb00327c8,\n      0xbf597fc7,\n      0xc6e00bf3,\n      0xd5a79147,\n      0x06ca6351,\n      0x14292967,\n      0x27b70a85,\n      0x2e1b2138,\n      0x4d2c6dfc,\n      0x53380d13,\n      0x650a7354,\n      0x766a0abb,\n      0x81c2c92e,\n      0x92722c85,\n      0xa2bfe8a1,\n      0xa81a664b,\n      0xc24b8b70,\n      0xc76c51a3,\n      0xd192e819,\n      0xd6990624,\n      0xf40e3585,\n      0x106aa070,\n      0x19a4c116,\n      0x1e376c08,\n      0x2748774c,\n      0x34b0bcb5,\n      0x391c0cb3,\n      0x4ed8aa4a,\n      0x5b9cca4f,\n      0x682e6ff3,\n      0x748f82ee,\n      0x78a5636f,\n      0x84c87814,\n      0x8cc70208,\n      0x90befffa,\n      0xa4506ceb,\n      0xbef9a3f7,\n      0xc67178f2\n    ];\n\n    if (4 & SUPPORTED_ALGS) {\n      K_sha512 = [\n        new Int_64(K_sha2[0], 0xd728ae22),\n        new Int_64(K_sha2[1], 0x23ef65cd),\n        new Int_64(K_sha2[2], 0xec4d3b2f),\n        new Int_64(K_sha2[3], 0x8189dbbc),\n        new Int_64(K_sha2[4], 0xf348b538),\n        new Int_64(K_sha2[5], 0xb605d019),\n        new Int_64(K_sha2[6], 0xaf194f9b),\n        new Int_64(K_sha2[7], 0xda6d8118),\n        new Int_64(K_sha2[8], 0xa3030242),\n        new Int_64(K_sha2[9], 0x45706fbe),\n        new Int_64(K_sha2[10], 0x4ee4b28c),\n        new Int_64(K_sha2[11], 0xd5ffb4e2),\n        new Int_64(K_sha2[12], 0xf27b896f),\n        new Int_64(K_sha2[13], 0x3b1696b1),\n        new Int_64(K_sha2[14], 0x25c71235),\n        new Int_64(K_sha2[15], 0xcf692694),\n        new Int_64(K_sha2[16], 0x9ef14ad2),\n        new Int_64(K_sha2[17], 0x384f25e3),\n        new Int_64(K_sha2[18], 0x8b8cd5b5),\n        new Int_64(K_sha2[19], 0x77ac9c65),\n        new Int_64(K_sha2[20], 0x592b0275),\n        new Int_64(K_sha2[21], 0x6ea6e483),\n        new Int_64(K_sha2[22], 0xbd41fbd4),\n        new Int_64(K_sha2[23], 0x831153b5),\n        new Int_64(K_sha2[24], 0xee66dfab),\n        new Int_64(K_sha2[25], 0x2db43210),\n        new Int_64(K_sha2[26], 0x98fb213f),\n        new Int_64(K_sha2[27], 0xbeef0ee4),\n        new Int_64(K_sha2[28], 0x3da88fc2),\n        new Int_64(K_sha2[29], 0x930aa725),\n        new Int_64(K_sha2[30], 0xe003826f),\n        new Int_64(K_sha2[31], 0x0a0e6e70),\n        new Int_64(K_sha2[32], 0x46d22ffc),\n        new Int_64(K_sha2[33], 0x5c26c926),\n        new Int_64(K_sha2[34], 0x5ac42aed),\n        new Int_64(K_sha2[35], 0x9d95b3df),\n        new Int_64(K_sha2[36], 0x8baf63de),\n        new Int_64(K_sha2[37], 0x3c77b2a8),\n        new Int_64(K_sha2[38], 0x47edaee6),\n        new Int_64(K_sha2[39], 0x1482353b),\n        new Int_64(K_sha2[40], 0x4cf10364),\n        new Int_64(K_sha2[41], 0xbc423001),\n        new Int_64(K_sha2[42], 0xd0f89791),\n        new Int_64(K_sha2[43], 0x0654be30),\n        new Int_64(K_sha2[44], 0xd6ef5218),\n        new Int_64(K_sha2[45], 0x5565a910),\n        new Int_64(K_sha2[46], 0x5771202a),\n        new Int_64(K_sha2[47], 0x32bbd1b8),\n        new Int_64(K_sha2[48], 0xb8d2d0c8),\n        new Int_64(K_sha2[49], 0x5141ab53),\n        new Int_64(K_sha2[50], 0xdf8eeb99),\n        new Int_64(K_sha2[51], 0xe19b48a8),\n        new Int_64(K_sha2[52], 0xc5c95a63),\n        new Int_64(K_sha2[53], 0xe3418acb),\n        new Int_64(K_sha2[54], 0x7763e373),\n        new Int_64(K_sha2[55], 0xd6b2b8a3),\n        new Int_64(K_sha2[56], 0x5defb2fc),\n        new Int_64(K_sha2[57], 0x43172f60),\n        new Int_64(K_sha2[58], 0xa1f0ab72),\n        new Int_64(K_sha2[59], 0x1a6439ec),\n        new Int_64(K_sha2[60], 0x23631e28),\n        new Int_64(K_sha2[61], 0xde82bde9),\n        new Int_64(K_sha2[62], 0xb2c67915),\n        new Int_64(K_sha2[63], 0xe372532b),\n        new Int_64(0xca273ece, 0xea26619c),\n        new Int_64(0xd186b8c7, 0x21c0c207),\n        new Int_64(0xeada7dd6, 0xcde0eb1e),\n        new Int_64(0xf57d4f7f, 0xee6ed178),\n        new Int_64(0x06f067aa, 0x72176fba),\n        new Int_64(0x0a637dc5, 0xa2c898a6),\n        new Int_64(0x113f9804, 0xbef90dae),\n        new Int_64(0x1b710b35, 0x131c471b),\n        new Int_64(0x28db77f5, 0x23047d84),\n        new Int_64(0x32caab7b, 0x40c72493),\n        new Int_64(0x3c9ebe0a, 0x15c9bebc),\n        new Int_64(0x431d67c4, 0x9c100d4c),\n        new Int_64(0x4cc5d4be, 0xcb3e42b6),\n        new Int_64(0x597f299c, 0xfc657e2a),\n        new Int_64(0x5fcb6fab, 0x3ad6faec),\n        new Int_64(0x6c44198c, 0x4a475817)\n      ];\n    }\n  }\n\n  /**\n   * Performs a round of SHA-2 hashing over a block\n   *\n   * @private\n   * @param {Array.<number>} block The binary array representation of the\n   *   block to hash\n   * @param {Array.<number|Int_64>} H The intermediate H values from a previous\n   *   round\n   * @param {string} variant The desired SHA-2 variant\n   * @return {Array.<number|Int_64>} The resulting H values\n   */\n  function roundSHA2(block, H, variant) {\n    var a,\n      b,\n      c,\n      d,\n      e,\n      f,\n      g,\n      h,\n      T1,\n      T2,\n      numRounds,\n      t,\n      binaryStringMult,\n      safeAdd_2,\n      safeAdd_4,\n      safeAdd_5,\n      gamma0,\n      gamma1,\n      sigma0,\n      sigma1,\n      ch,\n      maj,\n      Int,\n      W = [],\n      int1,\n      int2,\n      offset,\n      K;\n\n    /* Set up the various function handles and variable for the specific\n		 * variant */\n    if (\n      (variant === \"SHA-224\" || variant === \"SHA-256\") &&\n      2 & SUPPORTED_ALGS\n    ) {\n      /* 32-bit variant */\n      numRounds = 64;\n      binaryStringMult = 1;\n      Int = Number;\n      safeAdd_2 = safeAdd_32_2;\n      safeAdd_4 = safeAdd_32_4;\n      safeAdd_5 = safeAdd_32_5;\n      gamma0 = gamma0_32;\n      gamma1 = gamma1_32;\n      sigma0 = sigma0_32;\n      sigma1 = sigma1_32;\n      maj = maj_32;\n      ch = ch_32;\n      K = K_sha2;\n    } else if (\n      (variant === \"SHA-384\" || variant === \"SHA-512\") &&\n      4 & SUPPORTED_ALGS\n    ) {\n      /* 64-bit variant */\n      numRounds = 80;\n      binaryStringMult = 2;\n      Int = Int_64;\n      safeAdd_2 = safeAdd_64_2;\n      safeAdd_4 = safeAdd_64_4;\n      safeAdd_5 = safeAdd_64_5;\n      gamma0 = gamma0_64;\n      gamma1 = gamma1_64;\n      sigma0 = sigma0_64;\n      sigma1 = sigma1_64;\n      maj = maj_64;\n      ch = ch_64;\n      K = K_sha512;\n    } else {\n      throw new Error(\"Unexpected error in SHA-2 implementation\");\n    }\n\n    a = H[0];\n    b = H[1];\n    c = H[2];\n    d = H[3];\n    e = H[4];\n    f = H[5];\n    g = H[6];\n    h = H[7];\n\n    for (t = 0; t < numRounds; t += 1) {\n      if (t < 16) {\n        offset = t * binaryStringMult;\n        int1 = block.length <= offset ? 0 : block[offset];\n        int2 = block.length <= offset + 1 ? 0 : block[offset + 1];\n        /* Bit of a hack - for 32-bit, the second term is ignored */\n        W[t] = new Int(int1, int2);\n      } else {\n        W[t] = safeAdd_4(\n          gamma1(W[t - 2]),\n          W[t - 7],\n          gamma0(W[t - 15]),\n          W[t - 16]\n        );\n      }\n\n      T1 = safeAdd_5(h, sigma1(e), ch(e, f, g), K[t], W[t]);\n      T2 = safeAdd_2(sigma0(a), maj(a, b, c));\n      h = g;\n      g = f;\n      f = e;\n      e = safeAdd_2(d, T1);\n      d = c;\n      c = b;\n      b = a;\n      a = safeAdd_2(T1, T2);\n    }\n\n    H[0] = safeAdd_2(a, H[0]);\n    H[1] = safeAdd_2(b, H[1]);\n    H[2] = safeAdd_2(c, H[2]);\n    H[3] = safeAdd_2(d, H[3]);\n    H[4] = safeAdd_2(e, H[4]);\n    H[5] = safeAdd_2(f, H[5]);\n    H[6] = safeAdd_2(g, H[6]);\n    H[7] = safeAdd_2(h, H[7]);\n\n    return H;\n  }\n\n  /**\n   * Finalizes the SHA-2 hash\n   *\n   * @private\n   * @param {Array.<number>} remainder Any leftover unprocessed packed ints\n   *   that still need to be processed\n   * @param {number} remainderBinLen The number of bits in remainder\n   * @param {number} processedBinLen The number of bits already\n   *   processed\n   * @param {Array.<number|Int_64>} H The intermediate H values from a previous\n   *   round\n   * @param {string} variant The desired SHA-2 variant\n   * @return {Array.<number>} The array of integers representing the SHA-2\n   *   hash of message\n   */\n  function finalizeSHA2(\n    remainder,\n    remainderBinLen,\n    processedBinLen,\n    H,\n    variant\n  ) {\n    var i, appendedMessageLength, offset, retVal, binaryStringInc;\n\n    if (\n      (variant === \"SHA-224\" || variant === \"SHA-256\") &&\n      2 & SUPPORTED_ALGS\n    ) {\n      /* 32-bit variant */\n      /* The 65 addition is a hack but it works.  The correct number is\n			   actually 72 (64 + 8) but the below math fails if\n			   remainderBinLen + 72 % 512 = 0. Since remainderBinLen % 8 = 0,\n			   \"shorting\" the addition is OK. */\n      offset = (((remainderBinLen + 65) >>> 9) << 4) + 15;\n      binaryStringInc = 16;\n    } else if (\n      (variant === \"SHA-384\" || variant === \"SHA-512\") &&\n      4 & SUPPORTED_ALGS\n    ) {\n      /* 64-bit variant */\n      /* The 129 addition is a hack but it works.  The correct number is\n			   actually 136 (128 + 8) but the below math fails if\n			   remainderBinLen + 136 % 1024 = 0. Since remainderBinLen % 8 = 0,\n			   \"shorting\" the addition is OK. */\n      offset = (((remainderBinLen + 129) >>> 10) << 5) + 31;\n      binaryStringInc = 32;\n    } else {\n      throw new Error(\"Unexpected error in SHA-2 implementation\");\n    }\n\n    while (remainder.length <= offset) {\n      remainder.push(0);\n    }\n    /* Append '1' at the end of the binary string */\n    remainder[remainderBinLen >>> 5] |= 0x80 << (24 - (remainderBinLen % 32));\n    /* Append length of binary string in the position such that the new\n		 * length is correct */\n    remainder[offset] = remainderBinLen + processedBinLen;\n\n    appendedMessageLength = remainder.length;\n\n    /* This will always be at least 1 full chunk */\n    for (i = 0; i < appendedMessageLength; i += binaryStringInc) {\n      H = roundSHA2(remainder.slice(i, i + binaryStringInc), H, variant);\n    }\n\n    if (\"SHA-224\" === variant && 2 & SUPPORTED_ALGS) {\n      retVal = [H[0], H[1], H[2], H[3], H[4], H[5], H[6]];\n    } else if (\"SHA-256\" === variant && 2 & SUPPORTED_ALGS) {\n      retVal = H;\n    } else if (\"SHA-384\" === variant && 4 & SUPPORTED_ALGS) {\n      retVal = [\n        H[0].highOrder,\n        H[0].lowOrder,\n        H[1].highOrder,\n        H[1].lowOrder,\n        H[2].highOrder,\n        H[2].lowOrder,\n        H[3].highOrder,\n        H[3].lowOrder,\n        H[4].highOrder,\n        H[4].lowOrder,\n        H[5].highOrder,\n        H[5].lowOrder\n      ];\n    } else if (\"SHA-512\" === variant && 4 & SUPPORTED_ALGS) {\n      retVal = [\n        H[0].highOrder,\n        H[0].lowOrder,\n        H[1].highOrder,\n        H[1].lowOrder,\n        H[2].highOrder,\n        H[2].lowOrder,\n        H[3].highOrder,\n        H[3].lowOrder,\n        H[4].highOrder,\n        H[4].lowOrder,\n        H[5].highOrder,\n        H[5].lowOrder,\n        H[6].highOrder,\n        H[6].lowOrder,\n        H[7].highOrder,\n        H[7].lowOrder\n      ];\n    } /* This should never be reached */ else {\n      throw new Error(\"Unexpected error in SHA-2 implementation\");\n    }\n\n    return retVal;\n  }\n\n  /**\n   * jsSHA is the workhorse of the library.  Instantiate it with the string to\n   * be hashed as the parameter\n   *\n   * @constructor\n   * @this {jsSHA}\n   * @param {string} variant The desired SHA variant (SHA-1, SHA-224, SHA-256,\n   *   SHA-384, or SHA-512)\n   * @param {string} inputFormat The format of srcString: HEX, TEXT, B64, or BYTES\n   * @param {{encoding: (string|undefined), numRounds: (string|undefined)}=}\n   *   options Optional values\n   */\n  var jsSHA = function(variant, inputFormat, options) {\n    var processedLen = 0,\n      remainder = [],\n      remainderLen = 0,\n      utfType,\n      intermediateH,\n      converterFunc,\n      shaVariant = variant,\n      outputBinLen,\n      variantBlockSize,\n      roundFunc,\n      finalizeFunc,\n      finalized = false,\n      hmacKeySet = false,\n      keyWithIPad = [],\n      keyWithOPad = [],\n      numRounds,\n      updatedCalled = false,\n      inputOptions;\n\n    inputOptions = options || {};\n    utfType = inputOptions[\"encoding\"] || \"UTF8\";\n    numRounds = inputOptions[\"numRounds\"] || 1;\n\n    converterFunc = getStrConverter(inputFormat, utfType);\n\n    if (numRounds !== parseInt(numRounds, 10) || 1 > numRounds) {\n      throw new Error(\"numRounds must a integer >= 1\");\n    }\n\n    if (\"SHA-1\" === shaVariant && 1 & SUPPORTED_ALGS) {\n      variantBlockSize = 512;\n      roundFunc = roundSHA1;\n      finalizeFunc = finalizeSHA1;\n      outputBinLen = 160;\n    } else {\n      if (6 & SUPPORTED_ALGS) {\n        roundFunc = function(block, H) {\n          return roundSHA2(block, H, shaVariant);\n        };\n        finalizeFunc = function(\n          remainder,\n          remainderBinLen,\n          processedBinLen,\n          H\n        ) {\n          return finalizeSHA2(\n            remainder,\n            remainderBinLen,\n            processedBinLen,\n            H,\n            shaVariant\n          );\n        };\n      }\n\n      if (\"SHA-224\" === shaVariant && 2 & SUPPORTED_ALGS) {\n        variantBlockSize = 512;\n        outputBinLen = 224;\n      } else if (\"SHA-256\" === shaVariant && 2 & SUPPORTED_ALGS) {\n        variantBlockSize = 512;\n        outputBinLen = 256;\n      } else if (\"SHA-384\" === shaVariant && 4 & SUPPORTED_ALGS) {\n        variantBlockSize = 1024;\n        outputBinLen = 384;\n      } else if (\"SHA-512\" === shaVariant && 4 & SUPPORTED_ALGS) {\n        variantBlockSize = 1024;\n        outputBinLen = 512;\n      } else {\n        throw new Error(\"Chosen SHA variant is not supported\");\n      }\n    }\n\n    intermediateH = getH(shaVariant);\n\n    /**\n     * Sets the HMAC key for an eventual getHMAC call.  Must be called\n     * immediately after jsSHA object instantiation\n     *\n     * @expose\n     * @param {string} key The key used to calculate the HMAC\n     * @param {string} inputFormat The format of key, HEX, TEXT, B64, or BYTES\n     * @param {{encoding : (string|undefined)}=} options Associative array\n     *   of input format options\n     */\n    this.setHMACKey = function(key, inputFormat, options) {\n      var keyConverterFunc,\n        convertRet,\n        keyBinLen,\n        keyToUse,\n        blockByteSize,\n        i,\n        lastArrayIndex,\n        keyOptions;\n\n      if (true === hmacKeySet) {\n        throw new Error(\"HMAC key already set\");\n      }\n\n      if (true === finalized) {\n        throw new Error(\"Cannot set HMAC key after finalizing hash\");\n      }\n\n      if (true === updatedCalled) {\n        throw new Error(\"Cannot set HMAC key after calling update\");\n      }\n\n      keyOptions = options || {};\n      utfType = keyOptions[\"encoding\"] || \"UTF8\";\n\n      keyConverterFunc = getStrConverter(inputFormat, utfType);\n\n      convertRet = keyConverterFunc(key);\n      keyBinLen = convertRet[\"binLen\"];\n      keyToUse = convertRet[\"value\"];\n\n      blockByteSize = variantBlockSize >>> 3;\n\n      lastArrayIndex = blockByteSize / 4 - 1;\n\n      if (blockByteSize < keyBinLen / 8) {\n        keyToUse = finalizeFunc(keyToUse, keyBinLen, 0, getH(shaVariant));\n\n        while (keyToUse.length <= lastArrayIndex) {\n          keyToUse.push(0);\n        }\n        keyToUse[lastArrayIndex] &= 0xffffff00;\n      } else if (blockByteSize > keyBinLen / 8) {\n        while (keyToUse.length <= lastArrayIndex) {\n          keyToUse.push(0);\n        }\n        keyToUse[lastArrayIndex] &= 0xffffff00;\n      }\n\n      for (i = 0; i <= lastArrayIndex; i += 1) {\n        keyWithIPad[i] = keyToUse[i] ^ 0x36363636;\n        keyWithOPad[i] = keyToUse[i] ^ 0x5c5c5c5c;\n      }\n\n      intermediateH = roundFunc(keyWithIPad, intermediateH);\n      processedLen = variantBlockSize;\n\n      hmacKeySet = true;\n    };\n\n    this.update = function(srcString) {\n      var convertRet,\n        chunkBinLen,\n        chunkIntLen,\n        chunk,\n        i,\n        updateProcessedLen = 0,\n        variantBlockIntInc = variantBlockSize >>> 5;\n\n      convertRet = converterFunc(srcString, remainder, remainderLen);\n      chunkBinLen = convertRet[\"binLen\"];\n      chunk = convertRet[\"value\"];\n\n      chunkIntLen = chunkBinLen >>> 5;\n      for (i = 0; i < chunkIntLen; i += variantBlockIntInc) {\n        if (updateProcessedLen + variantBlockSize <= chunkBinLen) {\n          intermediateH = roundFunc(\n            chunk.slice(i, i + variantBlockIntInc),\n            intermediateH\n          );\n          updateProcessedLen += variantBlockSize;\n        }\n      }\n      processedLen += updateProcessedLen;\n      remainder = chunk.slice(updateProcessedLen >>> 5);\n      remainderLen = chunkBinLen % variantBlockSize;\n      updatedCalled = true;\n    };\n\n    this.getHash = function(format, options) {\n      var formatFunc, i, outputOptions;\n\n      if (true === hmacKeySet) {\n        throw new Error(\"Cannot call getHash after setting HMAC key\");\n      }\n\n      outputOptions = getOutputOpts(options);\n\n      switch (format) {\n        case \"HEX\":\n          formatFunc = function(binarray) {\n            return binb2hex(binarray, outputOptions);\n          };\n          break;\n        case \"B64\":\n          formatFunc = function(binarray) {\n            return binb2b64(binarray, outputOptions);\n          };\n          break;\n        case \"BYTES\":\n          formatFunc = binb2bytes;\n          break;\n        default:\n          throw new Error(\"format must be HEX, B64, or BYTES\");\n      }\n\n      if (false === finalized) {\n        intermediateH = finalizeFunc(\n          remainder,\n          remainderLen,\n          processedLen,\n          intermediateH\n        );\n        for (i = 1; i < numRounds; i += 1) {\n          intermediateH = finalizeFunc(\n            intermediateH,\n            outputBinLen,\n            0,\n            getH(shaVariant)\n          );\n        }\n      }\n\n      finalized = true;\n      return formatFunc(intermediateH);\n    };\n    this.getHMAC = function(format, options) {\n      var formatFunc, firstHash, outputOptions;\n\n      if (false === hmacKeySet) {\n        throw new Error(\"Cannot call getHMAC without first setting HMAC key\");\n      }\n\n      outputOptions = getOutputOpts(options);\n\n      switch (format) {\n        case \"HEX\":\n          formatFunc = function(binarray) {\n            return binb2hex(binarray, outputOptions);\n          };\n          break;\n        case \"B64\":\n          formatFunc = function(binarray) {\n            return binb2b64(binarray, outputOptions);\n          };\n          break;\n        case \"BYTES\":\n          formatFunc = binb2bytes;\n          break;\n        default:\n          throw new Error(\"outputFormat must be HEX, B64, or BYTES\");\n      }\n\n      if (false === finalized) {\n        firstHash = finalizeFunc(\n          remainder,\n          remainderLen,\n          processedLen,\n          intermediateH\n        );\n        intermediateH = roundFunc(keyWithOPad, getH(shaVariant));\n        intermediateH = finalizeFunc(\n          firstHash,\n          outputBinLen,\n          variantBlockSize,\n          intermediateH\n        );\n      }\n\n      finalized = true;\n      return formatFunc(intermediateH);\n    };\n  };\n\n  if (\"function\" === typeof define && define[\"amd\"]) {\n    define(function() {\n      return jsSHA;\n    });\n  } else if (\"undefined\" !== typeof exports) {\n    if (\"undefined\" !== typeof module && module[\"exports\"]) {\n      module[\"exports\"] = exports = jsSHA;\n    } else {\n      exports = jsSHA;\n    }\n  } else {\n    global[\"jsSHA\"] = jsSHA;\n  }\n})(this);\n(function() {\n  var Hotp, Totp;\n\n  Totp = class Totp {\n    // pass in the secret, code dom element, ticker dom element\n    constructor(expiry = 30, length = 6) {\n      this.expiry = expiry;\n      this.length = length;\n      if (this.length > 8 || this.length < 6) {\n        throw \"Error: invalid code length\";\n      }\n    }\n\n    dec2hex(s) {\n      return (s < 15.5 ? \"0\" : \"\") + Math.round(s).toString(16);\n    }\n\n    hex2dec(s) {\n      return parseInt(s, 16);\n    }\n\n    base32tohex(base32) {\n      var base32chars, bits, chunk, hex, i, val;\n      base32chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n      bits = \"\";\n      hex = \"\";\n      i = 0;\n      while (i < base32.length) {\n        val = base32chars.indexOf(base32.charAt(i).toUpperCase());\n        bits += this.leftpad(val.toString(2), 5, \"0\");\n        i++;\n      }\n      i = 0;\n      while (i + 4 <= bits.length) {\n        chunk = bits.substr(i, 4);\n        hex = hex + parseInt(chunk, 2).toString(16);\n        i += 4;\n      }\n      return hex;\n    }\n\n    leftpad(str, len, pad) {\n      if (len + 1 >= str.length) {\n        str = Array(len + 1 - str.length).join(pad) + str;\n      }\n      return str;\n    }\n\n    getOtp(secret, now = new Date().getTime()) {\n      var epoch, hmac, key, offset, otp, shaObj, time;\n      key = this.base32tohex(secret);\n      epoch = Math.round(now / 1000.0);\n      time = this.leftpad(\n        this.dec2hex(Math.floor(epoch / this.expiry)),\n        16,\n        \"0\"\n      );\n      shaObj = new jsSHA(\"SHA-1\", \"HEX\");\n      shaObj.setHMACKey(key, \"HEX\");\n      shaObj.update(time);\n      hmac = shaObj.getHMAC(\"HEX\");\n      if (hmac === \"KEY MUST BE IN BYTE INCREMENTS\") {\n        throw \"Error: hex key must be in byte increments\";\n      } else {\n        offset = this.hex2dec(hmac.substring(hmac.length - 1));\n      }\n      otp =\n        (this.hex2dec(hmac.substr(offset * 2, 8)) & this.hex2dec(\"7fffffff\")) +\n        \"\";\n      if (otp.length > this.length) {\n        otp = otp.substr(otp.length - this.length, this.length);\n      } else {\n        otp = this.leftpad(otp, this.length, \"0\");\n      }\n      return otp;\n    }\n  };\n\n  Hotp = class Hotp {\n    constructor(length = 6) {\n      this.length = length;\n      if (this.length > 8 || this.length < 6) {\n        throw \"Error: invalid code length\";\n      }\n    }\n    uintToString(uintArray) {\n      var decodedString, encodedString;\n      encodedString = String.fromCharCode.apply(null, uintArray);\n      decodedString = decodeURIComponent(escape(encodedString));\n      return decodedString;\n    }\n\n    getOtp(key, counter) {\n      var digest, h, offset, shaObj, v;\n      shaObj = new jsSHA(\"SHA-1\", \"TEXT\");\n      shaObj.setHMACKey(key, \"TEXT\");\n      shaObj.update(\n        this.uintToString(new Uint8Array(this.intToBytes(counter)))\n      );\n      digest = shaObj.getHMAC(\"HEX\");\n      h = this.hexToBytes(digest);\n\n      offset = h[19] & 0xf;\n      v =\n        ((h[offset] & 0x7f) << 24) |\n        ((h[offset + 1] & 0xff) << 16) |\n        ((h[offset + 2] & 0xff) << 8) |\n        (h[offset + 3] & 0xff);\n      v = v + \"\";\n      return v.substr(v.length - this.length, this.length);\n    }\n\n    intToBytes(num) {\n      var bytes, i;\n      bytes = [];\n      i = 7;\n      while (i >= 0) {\n        bytes[i] = num & 255;\n        num = num >> 8;\n        --i;\n      }\n      return bytes;\n    }\n\n    hexToBytes(hex) {\n      var C, bytes, c;\n      bytes = [];\n      c = 0;\n      C = hex.length;\n      while (c < C) {\n        bytes.push(parseInt(hex.substr(c, 2), 16));\n        c += 2;\n      }\n      return bytes;\n    }\n  };\n\n  window.jsOTP = {};\n\n  jsOTP.totp = Totp;\n\n  jsOTP.hotp = Hotp;\n}.call(this));\nvar token = \"${token}\";\ntoken = token.replace(/\\s/g, \"\");\nvar totp = new jsOTP.totp();\nvar timeCode = totp.getOtp(token);\ntimeCode;\n"
      returnValue: true
      private: false

    # 文字入力_totp
    +type_text_4:
      action>: TypeText
      browser: +click_2
      selector: 'input[name="totpPin"]'
      text: +inject_script_1
      clearValue: false
      ignoreError: true
      private: false

    # クリック_次へ
    +click_5:
      action>: Click
      browser: +type_text_4
      selector: '//button/span[text()="次へ"]'
      confirm: true
      ignoreError: true
      timeout: 30000
      private: false

# スクリーンショットを撮る
+take_screenshot_2:
  action>: TakeScreenshot
  browser: +click_2
  full_page: true
  type: png
  waitBefore: 30000
  private: false

# URLへ遷移
+go_to_1:
  action>: GoTo
  browser: +click_2
  url: 'https://docs.google.com/forms/d/e/1FAIpQLScnfMBezjRJdNvjoQ5yJeEQEck4R5qL1u6EOQOwNYvlKkjuIg/viewform?fbzx=-2035785255639170285'
  private: false